import os, time

from PlatformManager.Platforms.Platform import Platform

""" 
        @authors:
            Alejandro Balderrama
            Nadia Karichev
            Hector Cervantes
        @description
            This class is a subclass of platform. This class will implement the tiddlywiki platform. 
"""


class Results(Platform):
    # fill the values here for your specific platformResultsPlatform
    platform_name = "Results"
    platform_start_command = ""
    platform_end_command = ""
    platform_version = ""

   # the fields below will be generated by Platform Manager
    platform_install = ""
    platform_id = 0
    processID = 0
    subplatforms = {}
    port = "0"
    ip = "0.0.0.0"
    link = ""

    def requestHandler(self, command):
        action = {
            'getStatus': Results.getStatus,
            'getResults': Results.getResults
        }
        return action[command['command']](self, command['param'])

    # return process ID
    def getProcessID(self):
        return self.processID

    # returns link to connect to website
    def getLink(self):
        return self.link

    # returns ip and port to connect to website
    def getIpPort(self):
        return self.ip + ":" + self.port

    # returns platform name
    def getPlatformName(self):
        return self.platform_name

    # returns where the platforms installation path
    def getPlatformInstallation(self):
        return self.platform_install

    # return the version of the platform
    def getPlatformVersion(self):
        return self.platform_version

    # return a platformID. You can pick a random value for this field.
    def getPlatformID(self):
        return self.platform_id

    # return command that starts platform
    def get_start_command(self):
        return self.platform_start_command

    # returns command to stop platform
    def get_stop_command(self):
        return self.platform_end_command

    # returns list of subplatforms
    def get_sub_platforms(self):
        return self.subplatforms

    # sets process ID
    def setProcessID(self, processID):
        self.processID = processID

    # set link to connect to website
    def setLink(self, link):
        self.link = link

    # set ip and port to connect to website
    def setIpPort(self, ip, port):
        self.ip = ip
        self.port = port

        # set platform name
    def setPlatformName(self, platform_name):
        self.platform_name = platform_name

        # set where the platforms installation path
    def setPlatformInstallation(self, platformInstallation):
        self.platformInstallation = platformInstallation

        # sets the version of the platform
    def setPlatformVersion(self, platform_version):
        self.platform_version = platform_version

        # sets a platformID. You can pick a random value for this field.
    def setPlatformID(self, PlatformID):
        self.platform_id = PlatformID

        # sets command that starts platform
    def set_start_command(self, platform_start_command):
        self.platform_start_command = platform_start_command

        # set command to stop platform
    def set_stop_command(self, platform_end_command):
        self.platform_end_command = platform_end_command

        # set list of subplatforms
    def set_sub_platforms(self, subplatforms):
        self.subplatforms = subplatforms

    def getFilesFromDir(self):
        path = '/home/practicum/Desktop/hackathon_results'
        files = []
        subdirs = []
        for root, dirs, filenames in os.walk(path):
            for subdir in dirs:
                subdirs.append(os.path.relpath(os.path.join(root, subdir), path))

            for f in filenames:
                files.append(os.path.relpath(os.path.join(root, f), path))
        index = {}
        for f in files:
            index[f] = os.path.getmtime(os.path.join(path, f))
        files.sort()
        return files

    def init(self):
        return self.getFilesFromDir()

    def diff(self, list1, list2):
        diff_list = []
        for item in list1:
            if not item in list2:
                diff_list.append(item)
        return diff_list

    def writeToFile(self, name, list):
        f = open(name, 'w')
        for x in list:
            f.write(x + "\n")
        f.close()

    def compareWithBest(self):
        path = 'home/practicum/Desktop/hackathon_results'
        reportPath = path + "stats/"
        files = []
        reportsFiles = []
        currentMAXWinner = 0
        currentFileWinner = ' '

        for root, dirs, filenames in os.walk(reportPath):
            for f in filenames:
                files.append(os.path.relpath(os.path.join(root, f), reportPath))
        for f in files:
            if f.startswith('report_for_'):
                reportsFiles.append(f)

        for report in reportsFiles:
            ff = open(reportPath + report, 'r')
            num = int(ff.readline())
            print("Processing:\t", report, " with: ", num, "\twarnings")
            if int(currentMAXWinner) < int(num):
                currentMAXWinner = int(num)
                currentFileWinner = str(report)
            print("Winner is ", currentFileWinner, " with ", currentMAXWinner, " warnings.")

    def checkForWarnings(self, inF, out):
        path = '/home/practicum/Desktop/hackathon_results'
        reportPath = path + "stats/"
        inF = str(path + inF)
        stringToMatch = 'Analyzed'
        matchedLine = ''
        with open(inF, 'r') as file:
            for line in file:
                if stringToMatch in line:
                    matchedLine = line
                    break
        with open(reportPath + out, 'w') as file:
            file.write(str(matchedLine.split()[1]))
            file.close()

    def inspectFile(self, nf):
        reportFile = "report_for_" + nf
        self.checkForWarnings(nf, reportFile)

    def getStatus(self, group_id):
        path = '/home/practicum/Desktop/hackathon_results/' + 'stats/'
        fileToFind = 'report_for_group' + str(group_id) + '_Results.txt'
        #print("Status: ", os.path.exists(path + fileToFind))
        exists = os.path.exists(path+fileToFind)
        if exists:
            self.inspectFile(path+fileToFind)
        return exists

    def getResults(self, group_id):
        self.getStatus(group_id)
        path = '/home/practicum/Desktop/hackathon_results/' + 'stats/'
        fileToOpen = 'report_for_group' + str(group_id) + '_Results.txt'
        try:
            f = open(path+fileToOpen)
            groupResults = int(f.readline())
            #print('Results:', groupResults)
            return groupResults

        except Exception as ex:
            print(ex)
            print('The results for this group does not exist')
            return None

    def run(self):
        # Initial files in directory
        initial_curr_dir = self.init()
        print("Listening for new alerts...")
        status = True
        while 1:
            tmp = self.getFilesFromDir()
            if (len(self.diff(tmp, initial_curr_dir)) != 0):
                state = self.diff(tmp, initial_curr_dir)
                for newAlert in state:
                    print('Status:', status, "\n ******* ALERT: ", newAlert, " was added to folder ********")
                    self.inspectFile(newAlert)
                    self.compareWithBest()
                    initial_curr_dir = self.init()
                    self.getResults('1')
                    print("*********************************************************************\n")
                    #            option = input("What do you want to do? ")
                    time.sleep(2)

if __name__ == "__main__":
    app = Results()
    app.run()

    """command = {
        'command': 'getResults',
        'param': 99
    }
    app.request_handler(command)
    """