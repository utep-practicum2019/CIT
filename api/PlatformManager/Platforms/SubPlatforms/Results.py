import os, time, glob
#PlatformManager.
from .Platform import Platform
import threading

""" 
        @authors:
            Alejandro Balderrama
            Nadia Karichev
            Hector Cervantes
        @description
            This class is a subclass of platform. This class will implement the tiddlywiki platform. 
"""


class Results(Platform):
    # fill the values here for your specific platformResultsPlatform
    platform_name = "Results"
    platform_alias = ""
    platform_note = ""
    platform_date_created = ""
    platform_start_command = ""
    platform_end_command = ""
    platform_version = ""
    path_results = '/home/'+os.environ.get('USER')+'/Desktop/hackathon_results/'

    # the fields below will be generated by Platform Manager
    platform_install = ""
    platform_id = 0
    processID = 0
    subplatforms = {}
    port = "0"
    ip = "0.0.0.0"
    link = ""
    platform_alias = ""
    platform_note = ""
    thread = None
    running = False

    def requestHandler(self, command):
        action = {
            'getStatus': self.getStatus,
            'getResults': self.getResults
        }
        return action[command['command']](command['param'])

    # return process ID
    def getProcessID(self):
        return self.processID

    # returns link to connect to website
    def getLink(self):
        return self.link

    # returns ip and port to connect to website
    def getIpPort(self):
        return self.ip + ":" + self.port

    # returns platform name
    def getPlatformName(self):
        return self.platform_name

    #returns platform alias
    def getPlatformAlias(self):
        return self.platform_alias

    #returns platform note
    def getPlatformNote(self):
        return self.platform_note

    #get platform creation date
    def getPlatformDateCreated(self):
        return self.platform_date_created

    #returns where the platforms installation path
    def getPlatformInstallation(self):
        return self.platform_install

    # return the version of the platform
    def getPlatformVersion(self):
        return self.platform_version

    # return a platformID. You can pick a random value for this field.
    def getPlatformID(self):
        return self.platform_id

    # return command that starts platform
    def get_start_command(self):
        return self.platform_start_command

    # returns command to stop platform
    def get_stop_command(self):
        return self.platform_end_command

    # returns list of subplatforms
    def get_sub_platforms(self):
        return self.subplatforms

    # sets process ID
    def setProcessID(self, processID):
        self.processID = processID

    # set link to connect to website
    def setLink(self, link):
        self.link = link

    # set ip and port to connect to website
    def setIpPort(self, ip, port):
        self.ip = ip
        self.port = str(port)

        # set platform name
    def setPlatformName(self, platform_name):
        self.platform_name = platform_name

    #set platform alias
    def setPlatformAlias(self, alias):
        self.platform_alias = alias 

    #set platform note
    def setPlatformNote(self, note):
        self.platform_note = note

    #set platform creation date
    def setPlatformDateCreated(self, date):
        self.platform_date_created = date

    #set where the platforms installation path
    def setPlatformInstallation(self, platformInstallation):
        self.platformInstallation = platformInstallation

    # sets the version of the platform
    def setPlatformVersion(self, platform_version):
        self.platform_version = platform_version

    # sets a platformID. You can pick a random value for this field.
    def setPlatformID(self, PlatformID):
        self.platform_id = PlatformID

    # sets command that starts platform
    def set_start_command(self, platform_start_command):
        self.platform_start_command = platform_start_command

    # set command to stop platform
    def set_stop_command(self, platform_end_command):
        self.platform_end_command = platform_end_command

    # set list of subplatforms
    def set_sub_platforms(self, subplatforms):
        self.subplatforms = subplatforms

    def getFilesFromDir(self):
        path = Results.path_results
        files = []
        subdirs = []
        for root, dirs, filenames in os.walk(path):
            for subdir in dirs:
                subdirs.append(os.path.relpath(os.path.join(root, subdir), path))

            for f in filenames:
                files.append(os.path.relpath(os.path.join(root, f), path))
        index = {}
        for f in files:
            if os.path.exists(f):
                os.remove(f)
                index[f] = os.path.getmtime(os.path.join(path, f))
            files.sort()
        return files

    def init(self):
        return self.getFilesFromDir()

    def diff(self, list1, list2):
        diff_list = []
        for item in list1:
            if not item in list2:
                diff_list.append(item)
        return diff_list

    def writeToFile(self, name, list):
        f = open(name, 'w')
        for x in list:
            f.write(x + "\n")
        f.close()

    def compareWithBest(self):
        path = Results.path_results
        reportPath = path + "/stats/"
        files = []
        reportsFiles = []
        currentMAXWinner = 0
        currentFileWinner = ' '

        for root, dirs, filenames in os.walk(reportPath):
            for f in filenames:
                files.append(os.path.relpath(os.path.join(root, f), reportPath))
        for f in files:
            if f.startswith('report_for_'):
                reportsFiles.append(f)

        for report in reportsFiles:
            ff = open(reportPath + report, 'r')
            num = int(ff.readline())
            print("Processing:\t", report, " with: ", num, "\twarnings")
            if int(currentMAXWinner) < int(num):
                currentMAXWinner = int(num)
                currentFileWinner = str(report)
            print("Winner is ", currentFileWinner, " with ", currentMAXWinner, " warnings.")

    def checkForWarnings(self, inF, out):
        path = Results.path_results
        reportPath = path + "/stats/"
        stringToMatch = 'Analyzed'
        matchedLine = ''
        with open(inF, 'r') as file:
            for line in file:
                if stringToMatch in line:
                    matchedLine = line
                    break
        out = out.split('/')
        out = out[len(out) - 1]
        out = reportPath + out
        with open(out, 'w') as file:
            file.write(str(matchedLine.split()[1]))
            file.close()

    def inspectFile(self, nf):
        reportFile = nf
        self.checkForWarnings(nf, reportFile)

    def getStatus(self, param):
        filename = param['filename']
        fileToFind = ''
        full_path = Results.path_results + filename
        for name in glob.glob(full_path):
            fileToFind = name
        exists = os.path.exists(fileToFind)
        print("Status stat: ", os.path.exists(fileToFind))
        if exists:
            self.inspectFile(fileToFind)
        return {"done": exists}

    def getResults(self, param):
        filename = param['filename']
        fileToOpen = ''
        for name in glob.glob(Results.path_results+'/stats/' + filename):
            fileToOpen = name
            print('fs', fileToOpen)
        try:
            f = open(fileToOpen)
            groupResults = int(f.readline())
            print('Results:', groupResults)
            return {"results": groupResults}

        except Exception as ex:
            print(ex)
            print('The results for this group does not exist')
        return None

    def run(self):
        # Initial files in directory
        initial_curr_dir = self.init()
        print("Results listening for new alerts...")
        status = True
        while self.running:
            print("results probing...")
            tmp = self.getFilesFromDir()
            if (len(self.diff(tmp, initial_curr_dir)) != 0):
                print("results file found")
                state = self.diff(tmp, initial_curr_dir)
                for newAlert in state:
                    # print('Status:', status, "\n ******* ALERT: ", newAlert, " was added to folder ********")
                    self.inspectFile(newAlert)
                    self.compareWithBest()
                    initial_curr_dir = self.init()
                    self.getStatus('77')
                    self.getResults('77')
                    # print("*********************************************************************\n")
                    #            option = input("What do you want to do? ")
            time.sleep(2000)

        print("Results stopped.")

# if __name__ == "__main__":
#     app = Results()
#     app.run()
#
#     """command = {
#         'command': 'getResults',
#         'param': 99
#     }
#     app.request_handler(command)
#     """
